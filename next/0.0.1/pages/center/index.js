
import Head from 'next/head'
import styles from '../../styles/Home.module.css'

/**
 * pages：（/pages 目录）
 *    1、这个目录下的文件（.js/.jsx/.ts/.tsx）都是用文件名作为路由；
 *    2、动态渲染
 *
 * 预渲染：
 *      对于vue/react来说，都是一个简单的html代码，里面包含的dom很少，对于dom的渲染
 *      就是使用js进行渲染的，所以这个对于seo并不好，
 *
 *
 * 页面的渲染方面：
 *      1、静态的渲染；
 *      2、服务端的渲染；
 *      3、客户端的渲染（就是vue/react的渲染方式）;
 * 三大渲染方式的使用场合：
 *    一、静态渲染：
 *        每次请求的时候，该页面会得到重用，cdn会进行缓存；
 *        1、生成不需要数据的静态页面（也就是说，不通过调用额外的函数去获取数据）；
 *
 *        2、需要获取数据的静态生成；（ 你是需要静态的生成，但是你的静态页面也是需要外部数据的注入 ）
 *           一般这种操作就是先进行数据的获取，之后呢，再进行页面的静态渲染；
 *            async getStaticProps 获取页面需要的异步数据；
 *            async getStaticPaths 获取动态路径，展示不同的路径；
 *      什么时候使用静态的渲染：
 *          您应该问问自己：“我可以在用户请求之前预先渲染此页面吗？” 如果答案是肯定的，则应选择“静态生成”。
 *      总结一下静态渲染的规则：
 *          1、页面结构一开始固定，不依赖与数据的动态变化；
 *          2、如果依赖数据，这个数据也是相对固定的，而不是动态变化的，因为这种获取数据之后静态的生成html的方式
 *             其实就是在build请求数据，拿到数据之后，将数据传入到react组件中，再进行生成html文件；
 *
 *
 *    二、服务端渲染（ssr/动态渲染）
 *       每次请求的时候都会生成新的html页面，cdn不会进行缓存，不会静态的生成html文件；
 *
 *
 * */

export default function Index({ posts,notFound }) {
  console.log('cnter-index', posts, notFound);
  let show =  <main className={styles.main}>
    <h1 className={styles.title}>
      这是一个用户的中心页！
      { posts.map((item, index)=>{
        return <div key={ index }>{ item }</div>
      }) }
    </h1>
  </main>;

  let notShow =  <main>404</main>;
  return (
      <div className={styles.container}>
        <Head>
          <title>information</title>
          <meta name="description" content="Generated by create next app" />
          <link rel="icon" href="/favicon.ico" />
        </Head>
        { notFound?notShow:show }


      </div>
  )
}


// 此函数在构建时被调用 静态的渲染
export async function getStaticProps() {
  let posts = []

  // 需要等到数据都请求回来了才会开始渲染响应请求
  let res = await new Promise((resolve, reject)=>{
    setTimeout(()=>{
     resolve([1,2,3,4])
    }, 2000)
  })

  posts = res;

  // 通过返回 { props: { posts } } 对象，组件将接收你传入的props
  return {
    // 会被解构
    props: {
      posts,
      revalidate: 16,
      notFound: false
    },
  }
}


// 服务端的渲染
// export async function getServerSideProps() {
//   let posts = []
//
//   // 需要等到数据都请求回来了才会开始渲染响应请求
//   let res = await new Promise((resolve, reject)=>{
//     setTimeout(()=>{
//      resolve([1,2,3,4])
//     }, 2000)
//   })
//
//   posts = res
//
//   // Pass data to the page via props
//   return { props: { posts } }
// }



/**
 * 数据获取：
 *   静态渲染：
 *    1、getStaticProps：就是在静态生成html的时候，获取数据用的
 *      其实就是在计算（running）到结果之后，生成一个json文件，当你的路由加载到这个页面，这个json文件就会背加载，里面的数据就会被使用，
 *      但是这个函数在客户端就不会被执行，简单也就是加载json文件而已；
 *        参数：context
 *            包裹：
 *                1、params 就是动态路由的参数；
 *                2、preview 页面是否处于预览模式（也就是暂时绕过静态生成）；
 *                3、previewData 设置的预览数据；
 *                4、locale 活动区域设置
 *                5、locales 所有支持的语言环境
 *                6、defaultLocale 默认的语言环境
 *        返回值：
 *            其中的包裹属性：
 *                1、props 是传递到页面渲染组件的参数；
 *                2、revalidate 默认值 false，也就是页面是否需要构建，在几秒之后；
 *                3、notFound true/false ,允许页面返回404或者正常页面
 *
 *        注意：
 *            1、只允许在页面的文件中导出，非页面文件不允许，原因就是react在呈现页面之前需要这个数据；
 *
 *
 *        2、getStaticPaths
 *           如果当前页面是动态路由所呈现的页面，在使用getStaticProps获取数据的时候，必须指定参数路由，
 *           就是可以让next在生成html文件的时候，生成对应的动态路由所呈现的静态的html页面；
 *
 *           返回值：
 *              paths 数组，其中单个元素包含页面所需要的路由参数
 *              fallback: false 默认 当在paths没有返回，当访问到该路径的时候，都会返回404
 *
 *          注意：
 *            当你使用动态路由，且还是需要生成静态html文件
 *
 *    服务端渲染：
 *        1、getServerSideProps(context)
 *          查看文档
 *
 *      注意：
 *         什么时候使用：
 *            如果你需要每次请求数据进行渲染，就可以使用
 *         1、只在服务端上运行，拿到数据之后返回，服务端渲染出页面之后才会返回html
 *         
 *
 *
 *
 *
 * */